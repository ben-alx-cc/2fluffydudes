<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive Hero – Zwei Kugeln</title>
  <style>
    :root {
      --bg1: #0b0f1a;
      --bg2: #111a2b;
      --txt: rgba(255,255,255,.9);
      --accent: #8ab4ff;
    }
    html, body { height: 100%; margin: 0; }
    body {
      background: radial-gradient(1200px 800px at 70% 20%, #101b2e 0%, var(--bg1) 50%),
                  radial-gradient(1000px 600px at 10% 80%, #0e1322 0%, var(--bg2) 50%),
                  linear-gradient(180deg, #0c1120 0%, #070b13 100%);
      overflow: hidden; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: var(--txt);
    }
    .overlay {
      position: fixed; inset: 0; pointer-events: none; display: grid; place-items: center;}
    .hud { position: absolute; top: 24px; left: 24px; padding: 12px 14px; border-radius: 14px; backdrop-filter: blur(8px);
           background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,.06); box-shadow: 0 10px 30px rgba(0,0,0,.25);}
    .hud h1 { margin: 0 0 4px 0; font-size: clamp(18px, 2.4vw, 26px); letter-spacing: .2px; }
    .hud p { margin: 0; opacity: .8; font-size: 13px }
    .badge { position: absolute; bottom: 20px; right: 20px; font-size: 12px; opacity: .7 }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="overlay">
    <div class="hud">
      <h1>Zwei interaktive Kugeln</h1>
      <p>Bewege die Maus • Klicken = Gummi-Effekt</p>
    </div>
    <div class="badge">Three.js WebGL • Noise‑Deformation</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
  (() => {
    const app = document.getElementById('app');

    // Scene setup
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 4.2);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    // Lights
    const light1 = new THREE.DirectionalLight(0xffffff, 1.0); light1.position.set(3, 2, 2); scene.add(light1);
    const light2 = new THREE.DirectionalLight(0x99ccff, 0.6); light2.position.set(-2, -1, 2); scene.add(light2);
    const ambient = new THREE.AmbientLight(0x335577, 0.45); scene.add(ambient);

    // ---------- GLSL: 3D Simplex Noise ----------
    const simplexGLSL = `
    vec3 mod289(vec3 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
    vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
    vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);} 
    vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;} 
    float snoise(vec3 v){
      const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
      const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
      vec3 i  = floor(v + dot(v, C.yyy));
      vec3 x0 =   v - i + dot(i, C.xxx) ;
      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min( g.xyz, l.zxy );
      vec3 i2 = max( g.xyz, l.zxy );
      vec3 x1 = x0 - i1 + C.xxx;
      vec3 x2 = x0 - i2 + C.yyy;
      vec3 x3 = x0 - D.yyy;
      i = mod289(i);
      vec4 p = permute( permute( permute(
                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
               + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
      float n_ = 0.142857142857; // 1/7
      vec3  ns = n_ * D.wyz - D.xzx;
      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_ );
      vec4 x = x_ *ns.x + ns.yyyy;
      vec4 y = y_ *ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);
      vec4 b0 = vec4( x.xy, y.xy );
      vec4 b1 = vec4( x.zw, y.zw );
      vec4 s0 = floor(b0)*2.0 + 1.0;
      vec4 s1 = floor(b1)*2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));
      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
      vec3 p0 = vec3(a0.xy,h.x);
      vec3 p1 = vec3(a1.xy,h.y);
      vec3 p2 = vec3(a0.zw,h.z);
      vec3 p3 = vec3(a1.zw,h.w);
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
      p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
    }`;

    // ---------- Deforming Blob (shader material) ----------
    const makeUniforms = (base, edge) => ({
      uTime: { value: 0 },
      uAmp: { value: 0.45 },
      uFreq: { value: 1.6 },
      uMouse: { value: new THREE.Vector2(0.0, 0.0) },
      uBaseColor: { value: new THREE.Color(base) },
      uEdgeColor: { value: new THREE.Color(edge) },
      uLight: { value: new THREE.Vector3(0.6, 0.8, 1.0) },
    });

    const vertexShader = `
      uniform float uTime; uniform float uAmp; uniform float uFreq; uniform vec2 uMouse; 
      ${simplexGLSL}
      varying vec3 vNormal; varying vec3 vPos; varying float vN;
      void main(){
        vec3 p = position;
        float t = uTime * 0.35;
        // mouse influence: subtle pull along X/Y
        vec3 dir = normalize(vec3(uMouse.x, uMouse.y, 0.3));
        float m = dot(normalize(p), dir);
        float n = snoise(normal + vec3(t*0.5, t*0.3, t*0.2) + p * uFreq);
        float d = (n * 0.5 + 0.5) * uAmp * (0.7 + 0.6 * m);
        p += normal * d;
        vN = n; vNormal = normalMatrix * normalize(normal);
        vec4 mv = modelViewMatrix * vec4(p, 1.0);
        vPos = mv.xyz; gl_Position = projectionMatrix * mv;
      }`;

    const fragmentShader = `
      precision highp float; varying vec3 vNormal; varying vec3 vPos; varying float vN;
      uniform vec3 uLight; uniform vec3 uBaseColor; uniform vec3 uEdgeColor;
      void main(){
        vec3 N = normalize(vNormal);
        vec3 L = normalize(uLight);
        float diff = clamp(dot(N,L), 0.0, 1.0);
        float fres = pow(1.0 - max(dot(N, normalize(-vPos)), 0.0), 2.0);
        vec3 col = mix(uBaseColor, uEdgeColor, fres);
        col *= (0.35 + 0.75 * diff);
        col += 0.08 * vec3(0.6,0.9,1.0) * (vN * 0.5 + 0.5);
        gl_FragColor = vec4(col, 1.0);
      }`;

    // Blue blob (links)
    const icoA = new THREE.IcosahedronGeometry(1, 180);
    const uniformsA = makeUniforms('#8ab4ff', '#aef0ff');
    const matA = new THREE.ShaderMaterial({ uniforms: uniformsA, vertexShader, fragmentShader });
    const blobA = new THREE.Mesh(icoA, matA); blobA.position.x = -0.95; scene.add(blobA);

    // Pastell‑Pink blob (rechts)
    const icoB = new THREE.IcosahedronGeometry(1, 180);
    const uniformsB = makeUniforms('#ffb3c7', '#ffd1e0');
    const matB = new THREE.ShaderMaterial({ uniforms: uniformsB, vertexShader, fragmentShader });
    const blobB = new THREE.Mesh(icoB, matB); blobB.position.x = 0.95; scene.add(blobB);

    // Particles backdrop
    const starCount = 1800;
    const ptsGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      const r = 7 + Math.random() * 4;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2*Math.random()-1);
      const x = r * Math.sin(phi) * Math.cos(theta);
      const y = r * Math.sin(phi) * Math.sin(theta);
      const z = r * Math.cos(phi);
      positions.set([x,y,z], i*3);
    }
    ptsGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const ptsMat = new THREE.PointsMaterial({ size: 0.012, transparent: true, opacity: 0.75 });
    const stars = new THREE.Points(ptsGeo, ptsMat);
    scene.add(stars);

    // Interaction state & rubber/spring effect
    const mouse = new THREE.Vector2(0,0); const targetRot = new THREE.Euler();
    let dragging = false; let lastX = 0, lastY = 0; let scrollOffset = 0;

    // spring state for "Gummi" punch
    let ampBoost = 0; let ampVel = 0;
    const BASE_AMP = 0.45;

    window.addEventListener('pointermove', (e) => {
      const x = (e.clientX / window.innerWidth) * 2 - 1;
      const y = (e.clientY / window.innerHeight) * 2 - 1;
      mouse.set(x, -y);
      uniformsA.uMouse.value.lerp(mouse, 0.25);
      uniformsB.uMouse.value.lerp(mouse, 0.25);
      targetRot.y = x * 0.5; targetRot.x = -y * 0.3;
    });

    window.addEventListener('pointerdown', (e) => {
      dragging = true; lastX = e.clientX; lastY = e.clientY;
      // add an impulse to the spring + tiny camera nudge
      ampVel += 1.8; scrollOffset += 0.06; if (scrollOffset > 0.9) scrollOffset = 0.9;
      // quick spin tease
      blobA.rotation.y += 0.12; blobB.rotation.y -= 0.12;
    });
    window.addEventListener('pointerup', () => dragging = false);

    window.addEventListener('pointermove', (e) => {
      if(!dragging) return;
      const dx = (e.clientX - lastX) / window.innerWidth; const dy = (e.clientY - lastY) / window.innerHeight;
      camera.rotation.y -= dx * 0.8; camera.rotation.x -= dy * 0.5;
      lastX = e.clientX; lastY = e.clientY;
    });

    window.addEventListener('wheel', (e) => {
      scrollOffset += e.deltaY * 0.0006; scrollOffset = Math.min(Math.max(scrollOffset, -0.6), 0.9);
    }, { passive: true });

    // Resize
    function onResize(){
      camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    // Animate
    let t0 = performance.now();
    function tick(){
      const now = performance.now(); const dt = (now - t0) / 1000; t0 = now;
      // advance times independently for subtle de-sync
      uniformsA.uTime.value += dt;
      uniformsB.uTime.value += dt * 1.05;

      // spring (critically damped-ish)
      const k = 10.0, c = 2.3; // stiffness & damping
      const acc = -k * ampBoost - c * ampVel;
      ampVel += acc * dt; ampBoost += ampVel * dt;
      const ampNow = BASE_AMP + Math.max(0, ampBoost) * 0.22; // scale punch
      uniformsA.uAmp.value = ampNow;
      uniformsB.uAmp.value = ampNow * 1.05;

      // smooth rotations toward mouse orientation + gentle contra-rotation
      blobA.rotation.x += (targetRot.x - blobA.rotation.x) * 0.05;
      blobA.rotation.y += (targetRot.y - blobA.rotation.y) * 0.07;
      blobB.rotation.x += (targetRot.x*0.9 - blobB.rotation.x) * 0.05;
      blobB.rotation.y += ((-targetRot.y)*0.9 - blobB.rotation.y) * 0.07;

      // subtle camera dolly with wheel
      camera.position.z += ((4.2 + scrollOffset) - camera.position.z) * 0.08;

      // background motion
      stars.rotation.y += dt * 0.02; stars.rotation.x += dt * 0.005;

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    tick();

    // Clean up on hot-reload environments
    window.addEventListener('beforeunload', () => {
      renderer.dispose();
      matA.dispose(); matB.dispose();
      icoA.dispose(); icoB.dispose();
      ptsGeo.dispose();
    });
  })();
  </script>
</body>
</html>
